package com.atguigu.two;

/**
 * @program: study
 * @description: 内存模型以及gc垃圾回收算法
 * @author: guoxiaobing
 * @create: 2020-02-08 12:51
 */
public class MemoryModelDemo {
    /**
     * java内存分区
     * 1.虚拟机栈  类的局部变量 类的方法 每个方法被执行的同时会创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。
     * 2.本地方法栈 native修饰的方法
     * 3.程序计数器
     * 4.堆 对象分配内存的区域；
     * 5.方法区 类的信息静态变量静态方法 常量
     * 其中1 2 3线程私有 随着线程的创建和消亡而创建消亡 垃圾回收基本不回收他们三个地方
     * <p>
     * 4 5 多个线程共享是垃圾回收的主要地方
     * <p>
     * 青年代 老年代
     * 青年代分伊甸园去 from to 比例是8：1：1
     *
     * gc回收垃圾四大算法以及优缺点：
     *  引用计数算法
     *  优点：引用计数收集器可以很快的执行，交织在程序运行中。对程序需要不被长时间打断的实时环境比较有利。
     *  缺点：无法检测出循环引用。如父对象有一个对子对象的引用，子对象反过来引用父对象。这样，他们的引用计数永远不可能为0。
     *
     *  标记-清除算法
     *在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片。
     *
     * 标记-整理算法
     * 会将所有的存活对象往左端空闲空间移动，并更新对应的指针。标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题
     *
     *复制算法
     *
     * 它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用的内存空间一次清理掉，这样一来就不容易出现内存碎片的问题。
     *
     *
     * GCroots 用GCroots来看是否有引用以此来判断是否是垃圾 如果从GCroots到对象不可达则是垃圾
     * 1.虚拟机栈中引用的对象 就是方法中的对象 栈帧中本地变量表中引用的对象
     * 2.方法区中静态变量应用的对象
     * 3.方法区中常量引用的对象
     * 4.本地方法栈中引用的对象
     *
     * 对象计数器 每有一个引用则加一 释放一个则减一 当计数器为0时则说明没有引用了 可以回收现在都不用了 无法解决循环引用
     */
    public static void main(String[] args) {
        System.out.println("内存分区以及垃圾回收的算法");

        TestA testA = new TestA();
        TestB  testB = new TestB();

        testA.b = testB;
        testB.a =testA;
        testA = null;
        testB = null;
    }
}

class TestA{
    public TestB b;

}

class TestB{
    public TestA a;
}